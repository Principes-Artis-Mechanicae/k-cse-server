ApplyCreateDto.java


public record ApplyCreateDto(
	String studentName, String studentNumber,
	LockerFloor firstFloor, Integer firstHeight,
	LockerFloor secondFloor, Integer secondHeight
) {
	public Apply toEntity(Student student, ApplyPeriod period) {
		return Apply.builder()
			.student(student)
			.firstFloor(firstFloor)
			.firstHeight(firstHeight)
			.secondFloor(secondFloor)
			.secondHeight(secondHeight)
			.period(period)
			.status(ApplyStatus.APPLY)
			.build();
	}
}


ApplyReadDto.java


@Builder
public record ApplyReadDto(
	Long applyId,
	String studentName, String studentNumber,
	LockerFloor firstFloor, Integer firstHeight,
	LockerFloor secondFloor, Integer secondHeight,
	ApplyPeriod period, ApplyStatus status
) {
	public static ApplyReadDto fromEntity(Apply apply, Student student) {
		return ApplyReadDto.builder()
			.applyId(apply.getId())
			.studentName(student.getStudentName())
			.studentNumber(student.getStudentNumber())
			.firstFloor(apply.getFirstFloor())
			.firstHeight(apply.getFirstHeight())
			.secondFloor(apply.getSecondFloor())
			.secondHeight(apply.getSecondHeight())
			.period(apply.getPeriod())
			.status(apply.getStatus())
			.build();
	}
}


ApplyReportCreateDto.java

public record ApplyReportCreateDto(
	ApplyCreateDto apply, String content
) {
}


ApplyReportReadDto.java


@Builder
public record ApplyReportReadDto(
	ApplyReadDto apply, String content
) {
	public static ApplyReportReadDto of(ApplyReadDto apply, Report report) {
		return ApplyReportReadDto.builder()
			.apply(apply)
			.content(report.getContent())
			.build();
	}
}


ApplyUpdateDto.java


public record ApplyUpdateDto(
	String studentName, String studentNumber,
	LockerFloor firstFloor, Integer firstHeight,
	LockerFloor secondFloor, Integer secondHeight,
	ApplyPeriod period, ApplyStatus status
) {
}


ApplyController.java



@RestController("ExecutiveApplyController")
@RequestMapping("/apply")
@RequiredArgsConstructor
@PreAuthorize("hasRole('EXECUTIVE') and isAuthenticated()")
public class ApplyController {

}


ApplyController.java



@RestController("AnonymousApplyController")
@RequestMapping("/application")
@RequiredArgsConstructor
@PreAuthorize("permitAll()")
public class ApplyController {
	private final ApplyService applyService;

	@PostMapping("/primary")
	public ResponseEntity<ApiSuccessResult<ApplyReadDto>> applyPrimary(
		@RequestBody ApplyCreateDto requestBody
	) {
		ApplyReadDto responseBody = applyService.handlePrimaryApply(requestBody);
		return ResponseEntity
			.status(HttpStatus.CREATED)
			.body(ApiUtil.success(HttpStatus.CREATED, responseBody));
	}

	@PostMapping("/additional")
	public ResponseEntity<ApiSuccessResult<ApplyReadDto>> applyAdditional(
		@RequestBody ApplyCreateDto requestBody
	) {
		ApplyReadDto responseBody = applyService.handleAdditionalApply(requestBody);
		return ResponseEntity
			.status(HttpStatus.CREATED)
			.body(ApiUtil.success(HttpStatus.CREATED, responseBody));
	}

	@PostMapping("/replacement")
	public ResponseEntity<ApiSuccessResult<ApplyReportReadDto>> applyReplacement(
		@RequestBody ApplyReportCreateDto requestBody
	) {
		ApplyReportReadDto responseBody = applyService.handleReplacementApply(requestBody);
		return ResponseEntity
			.status(HttpStatus.CREATED)
			.body(ApiUtil.success(HttpStatus.CREATED, responseBody));
	}

	@GetMapping("/{studentNumber}")
	public ResponseEntity<ApiSuccessResult<ApplyReadDto>> getApply(
		@PathVariable String studentNumber
	) {
		ApplyReadDto responseBody = applyService.getApplyByStudentNumber(studentNumber);
		return ResponseEntity
			.status(HttpStatus.OK)
			.body(ApiUtil.success(HttpStatus.OK, responseBody));
	}
}


ApplyFormReadDto.java


@Builder
public record ApplyFormReadDto(
	Integer year, Integer semester,
	String firstApplyStartDate, String firstApplyEndDate,
	String semesterEndDate, ApplyFormStatus status
) {
	public static ApplyFormReadDto fromEntity(ApplyForm applyForm) {
		return ApplyFormReadDto.builder()
			.year(applyForm.getYear())
			.semester(applyForm.getSemester())
			.firstApplyStartDate(DateTimeUtil.localDateTimeToString(applyForm.getFirstApplyStartDate()))
			.firstApplyEndDate(DateTimeUtil.localDateTimeToString(applyForm.getFirstApplyEndDate()))
			.semesterEndDate(DateTimeUtil.localDateTimeToString(applyForm.getSemesterEndDate()))
			.status(applyForm.getStatus())
			.build();
	}
}


ApplyFormCreateDto.java


public record ApplyFormCreateDto(
	Integer year, Integer semester,
	String firstApplyStartDate, String firstApplyEndDate,
	String semesterEndDate
) {
	public ApplyForm toEntity() {
		return ApplyForm.builder()
			.year(year)
			.semester(semester)
			.firstApplyStartDate(DateTimeUtil.stringToLocalDateTime(firstApplyStartDate))
			.firstApplyEndDate(DateTimeUtil.stringToLocalDateTime(firstApplyEndDate))
			.semesterEndDate(DateTimeUtil.stringToLocalDateTime(semesterEndDate))
			.status(ApplyFormStatus.INACTIVE)
			.build();
	}
}


ApplyFormUpdateDto.java


@Builder
public record ApplyFormUpdateDto(
	String firstApplyStartDate, String firstApplyEndDate,
	String semesterEndDate, String status
) {
}


ApplyFormController.java




@RestController("ExecutiveApplyFormController")
@RequestMapping("/forms")
@RequiredArgsConstructor
@PreAuthorize("hasRole('EXECUTIVE') and isAuthenticated()")
public class ApplyFormController {
	private final ApplyFormService applyFormService;

	@PostMapping
	public ResponseEntity<ApiSuccessResult<ApplyFormReadDto>> createForm(
		@RequestBody ApplyFormCreateDto requestBody
	) {
		ApplyFormReadDto responseBody = applyFormService.createApplyForm(requestBody);
		return ResponseEntity
			.status(HttpStatus.CREATED)
			.body(ApiUtil.success(HttpStatus.CREATED, responseBody));
	}

	@PutMapping("/{year}/{semester}")
	public ResponseEntity<ApiSuccessResult<ApplyFormReadDto>> updateForm(
		@PathVariable Integer year,
		@PathVariable Integer semester,
		@RequestBody ApplyFormUpdateDto requestBody
	) {
		ApplyFormReadDto updatedForm = applyFormService.updateApplyForm(year, semester, requestBody);
		return ResponseEntity
			.status(HttpStatus.OK)
			.body(ApiUtil.success(HttpStatus.OK, updatedForm));
	}

	@DeleteMapping("/{year}/{semester}")
	public ResponseEntity<ApiUtil.ApiSuccessResult<Void>> deleteForm(
		@PathVariable Integer year,
		@PathVariable Integer semester
	) {
		applyFormService.deleteApplyForm(year, semester);
		return ResponseEntity
			.status(HttpStatus.NO_CONTENT)
			.body(ApiUtil.success(HttpStatus.NO_CONTENT));
	}

	@GetMapping
	public ResponseEntity<ApiSuccessResult<List<ApplyFormReadDto>>> getAllForms() {
		List<ApplyFormReadDto> forms = applyFormService.getAllApplyForms();
		return ResponseEntity
			.status(HttpStatus.OK)
			.body(ApiUtil.success(HttpStatus.OK, forms));
	}

	@GetMapping("/{year}/{semester}")
	public ResponseEntity<ApiSuccessResult<ApplyFormReadDto>> getFormByYearAndSemester(
		@PathVariable Integer year,
		@PathVariable Integer semester
	) {
		ApplyFormReadDto form = applyFormService.getApplyForm(year, semester);
		return ResponseEntity
			.status(HttpStatus.OK)
			.body(ApiUtil.success(HttpStatus.OK, form));
	}

	@PatchMapping("/{year}/{semester}")
	public ResponseEntity<ApiSuccessResult<ApplyFormReadDto>> updateFormStatus(
		@PathVariable Integer year,
		@PathVariable Integer semester
	) {
		ApplyFormReadDto updatedForm = applyFormService.updateApplyFormStatus(year, semester);
		return ResponseEntity
			.status(HttpStatus.OK)
			.body(ApiUtil.success(HttpStatus.OK, updatedForm));
	}
}


ApplyFormController.java



@RestController("AnonymousApplyFormController")
@RequestMapping("/forms")
@RequiredArgsConstructor
@PreAuthorize("permitAll()")
public class ApplyFormController {
	private final ApplyFormService applyFormService;

	@GetMapping("/now")
	public ResponseEntity<ApiSuccessResult<ApplyFormReadDto>> getNowForm() {
		ApplyFormReadDto responseBody = applyFormService.getNowApplyForm();
		return ResponseEntity
			.status(HttpStatus.OK)
			.body(ApiUtil.success(HttpStatus.OK, responseBody));
	}
}


StudentService.java




@Service
@RequiredArgsConstructor
public class StudentService {
    private final StudentRepository studentRepository;
    private final OAuth2UserInfoRepository oAuth2UserInfoRepository;

    @Transactional
    public OAuth2UserInfo saveOrReadOauth2UserInfo(Oauth2ResponseDto responseDto) {
        Optional<OAuth2UserInfo> oAuth2UserInfoOptional =
            oAuth2UserInfoRepository.findByEmail(responseDto.getEmail());
		return oAuth2UserInfoOptional.orElseGet(() ->
            oAuth2UserInfoRepository.save(responseDto.toEntity()));
    }

    public boolean isOAuth2UserInfoConnectedToStudent(OAuth2UserInfo oAuth2UserInfo) {
        return studentRepository.existsById(oAuth2UserInfo.getId());
    }

    public OAuth2UserInfo findOAuth2UserInfoByEmail(String email) {
		return oAuth2UserInfoRepository.findByEmail(email)
            .orElseThrow(OAuth2UserInfoNotFoundException::new);
    }

    public Student findStudentByOAuth2UserInfo(OAuth2UserInfo oAuth2UserInfo) {
        return studentRepository.findStudentById(oAuth2UserInfo.getId())
            .orElseThrow(StudentNotFoundException::new);
    }

    public Student findStudentByNameAndNumber(String studentName, String studentNumber) {
        return studentRepository.findByStudentNameAndStudentNumber(studentName, studentNumber)
            .orElseThrow(StudentNotFoundException::new);
    }

    public Student findStudentByStudentNumber(String studentNumber) {
        return studentRepository.findByStudentNumber(studentNumber)
            .orElseThrow(StudentNotFoundException::new);
    }
}


DuesService.java



@Service
@Transactional(readOnly = true)
@RequiredArgsConstructor
public class DuesService {
	private final DuesRepository duesRepository;

	/**
	 * 학생회비 납부 여부 설정
	 * - 만약 해당 학생이 학생회비를 납부한 기록이 있다면, 해당 기록을 수정한다.
	 * - 만약 해당 학생이 학생회비를 납부한 기록이 없다면, 새로운 기록을 생성한다.
	 * @param studentId 학생 식별자
	 * @param isDues 학생회비 납부 여부
	 */
	@Transactional
	public void updateDues(Long studentId, boolean isDues) {
		if (duesRepository.existsDuesById(studentId)) {
			Dues dues = duesRepository.findDuesById(studentId)
				.orElseThrow(DuesNotFoundException::new);
			modifyDues(dues, isDues);
		} else {
			saveDues(studentId, isDues);
		}
	}

	private void modifyDues(Dues dues, boolean isDues) {
		dues.updateDues(isDues);
		duesRepository.save(dues);
	}

	private void saveDues(Long studentId, boolean isDues) {
		duesRepository.save(
			Dues.builder()
				.id(studentId)
				.dues(isDues)
				.build()
		);
	}
}


ApplyService.java




@Service
@Transactional(readOnly = true)
@RequiredArgsConstructor
public class ApplyService {
	/* Internal Dependencies */
	private final ApplyRepository applyRepository;

	/* External Dependencies */
	private final ApplyFormService applyFormService;
	private final StudentService studentService;
	private final ReportService reportService;

	/**
	 * Handles the creation of a primary application.
	 *
	 * @param createDto The DTO containing application details.
	 * @return The DTO representing the created application.
	 */
	@Transactional
	public ApplyReadDto handlePrimaryApply(ApplyCreateDto createDto) {
		return processApplication(createDto, ApplyPeriod.PRIMARY);
	}

	/**
	 * Handles the creation of an additional application.
	 *
	 * @param createDto The DTO containing application details.
	 * @return The DTO representing the created application.
	 */
	@Transactional
	public ApplyReadDto handleAdditionalApply(ApplyCreateDto createDto) {
		return processApplication(createDto, ApplyPeriod.ADDITIONAL);
	}

	/**
	 * Handles the creation of a replacement application along with a report.
	 *
	 * @param createDto The DTO containing application and report details.
	 * @return The DTO representing the created application.
	 */
	@Transactional
	public ApplyReportReadDto handleReplacementApply(ApplyReportCreateDto createDto) {
		ApplyReadDto applyReadDto = processApplication(createDto.apply(), ApplyPeriod.REPLACEMENT);
		Report report = attachReport(createDto.content(), applyReadDto.applyId());
		return ApplyReportReadDto.of(applyReadDto, report);
	}

	/**
	 * Processes the application based on the specified period and report content.
	 *
	 * @param createDto    The DTO containing application details.
	 * @param period       The period of the application.
	 * @return The DTO representing the created application.
	 */
	private ApplyReadDto processApplication(ApplyCreateDto createDto, ApplyPeriod period) {
		ApplyForm activeApplyForm = applyFormService.getActiveApplyForm();
		validateApplicationPeriod(activeApplyForm, period);

		Student student = retrieveStudent(createDto);
		Apply apply = applyRepository.save(createDto.toEntity(student, period));

		return ApplyReadDto.fromEntity(apply, student);
	}

	/**
	 * Attaches a report to the specified application.
	 *
	 * @param content  The content of the report.
	 * @param applyId The ID of the application to attach the report to.
	 */
	private Report attachReport(String content, Long applyId) {
		Apply apply = applyRepository.findById(applyId)
			.orElseThrow(ApplyNotFoundException::new);
		return reportService.writeReport(content, apply);
	}

	/**
	 * Validates whether the current time is within the application period.
	 *
	 * @param applyForm The active application form.
	 * @param period    The period of the application.
	 */
	private void validateApplicationPeriod(ApplyForm applyForm, ApplyPeriod period) {
		LocalDateTime now = DateTimeUtil.now();
		if (!period.isWithinPeriod(applyForm, now)) {
			throw new InvalidApplyPeriodException();
		}
	}

	/**
	 * Retrieves the student based on the provided application details.
	 *
	 * @param createDto The DTO containing student details.
	 * @return The Student entity.
	 */
	private Student retrieveStudent(ApplyCreateDto createDto) {
		return studentService.findStudentByNameAndNumber(
			createDto.studentName(),
			createDto.studentNumber()
		);
	}

	/**
	 * Retrieves the application by the student number.
	 *
	 * @param studentNumber The student number to search for.
	 * @return The DTO representing the application.
	 */
	public ApplyReadDto getApplyByStudentNumber(String studentNumber) {
		Student student = studentService.findStudentByStudentNumber(studentNumber);
		Apply apply = applyRepository.findByStudent(student)
			.orElseThrow(ApplyNotFoundException::new);
		return ApplyReadDto.fromEntity(apply, student);
	}
}


ApplyFormService.java




@Service
@Transactional(readOnly = true)
@RequiredArgsConstructor
public class ApplyFormService {
	/* internal dependency */
	private final ApplyFormRepository applyFormRepository;

	@Transactional
	public ApplyFormReadDto createApplyForm(ApplyFormCreateDto requestBody) {
		/* Check if the student not exists */
		if (applyFormRepository.existsByYearAndSemester(requestBody.year(), requestBody.semester()))
			throw new ApplyFormDuplicatedException();

		/* Save the apply entity */
		ApplyForm applyForm = applyFormRepository.save(requestBody.toEntity());

		/* Return the created apply entity */
		return ApplyFormReadDto.fromEntity(applyForm);
	}


	@Transactional
	public ApplyFormReadDto updateApplyForm(Integer year, Integer semester, ApplyFormUpdateDto requestBody) {
		/* Check if the student exists */
		ApplyForm applyForm = applyFormRepository.findByYearAndSemester(year, semester)
			.orElseThrow(ApplyFormNotFoundException::new);

		/* Update the apply entity */
		applyForm.update(requestBody);
		applyFormRepository.save(applyForm);

		/* Return the updated apply entity */
		return ApplyFormReadDto.fromEntity(applyForm);
	}

	@Transactional
	public void deleteApplyForm(Integer year, Integer semester) {
		/* Check if the student exists */
		ApplyForm applyForm = applyFormRepository.findByYearAndSemester(year, semester)
			.orElseThrow(ApplyFormNotFoundException::new);

		/* Delete the apply entity */
		applyFormRepository.delete(applyForm);
	}

	public ApplyFormReadDto getApplyForm(Integer year, Integer semester) {
		/* Check if the student exists */
		ApplyForm applyForm = applyFormRepository.findByYearAndSemester(year, semester)
			.orElseThrow(ApplyFormNotFoundException::new);

		/* Return the apply entity */
		return ApplyFormReadDto.fromEntity(applyForm);
	}

	public List<ApplyFormReadDto> getAllApplyForms() {
		/* Return the apply entities */
		return applyFormRepository.findAll().stream()
			.map(ApplyFormReadDto::fromEntity)
			.collect(Collectors.toList());
	}

	@Transactional
	public ApplyFormReadDto updateApplyFormStatus(Integer year, Integer semester) {
		/* Check if the student exists */
		ApplyForm applyForm = applyFormRepository.findByYearAndSemester(year, semester)
			.orElseThrow(ApplyFormNotFoundException::new);

		/* Update the apply entity */
		if (applyForm.getStatus() == ApplyFormStatus.INACTIVE) {
			if (isActiveApplyForm())
				throw new ApplyFormDuplicatedException();
			applyForm.updateStatus(ApplyFormStatus.ACTIVE);
		} else {
			applyForm.updateStatus(ApplyFormStatus.INACTIVE);
		}

		applyFormRepository.save(applyForm);

		/* Return the updated apply entity */
		return ApplyFormReadDto.fromEntity(applyForm);
	}

	public ApplyFormReadDto getNowApplyForm() {
		ApplyForm applyForm = getActiveApplyForm();
		return ApplyFormReadDto.fromEntity(applyForm);
	}

	public boolean isActiveApplyForm() {
		long activeCount = applyFormRepository.countByStatus(ApplyFormStatus.ACTIVE);
		return activeCount == 1;
	}

	public ApplyForm getActiveApplyForm() {
		if (!isActiveApplyForm())
			throw new ApplyFormNotFoundException();
		return applyFormRepository.findByStatus(ApplyFormStatus.ACTIVE)
			.orElseThrow(ApplyFormNotFoundException::new);
	}
}


ReportService.java



@Service
@Transactional(readOnly = true)
@RequiredArgsConstructor
public class ReportService {
	/* internal dependency */
	private final ReportRepository reportRepository;

	@Transactional
	public Report writeReport(String content, Apply apply) {
		return reportRepository.save(Report.builder()
			.content(content)
			.apply(apply)
			.build());
	}
}


