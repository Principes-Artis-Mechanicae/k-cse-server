StudentService.java




@Service
@RequiredArgsConstructor
public class StudentService {
    private final StudentRepository studentRepository;
    private final OAuth2UserInfoRepository oAuth2UserInfoRepository;

    @Transactional
    public OAuth2UserInfo saveOrReadOauth2UserInfo(Oauth2ResponseDto responseDto) {
        Optional<OAuth2UserInfo> oAuth2UserInfoOptional =
            oAuth2UserInfoRepository.findByEmail(responseDto.getEmail());
		return oAuth2UserInfoOptional.orElseGet(() ->
            oAuth2UserInfoRepository.save(responseDto.toEntity()));
    }

    public boolean isOAuth2UserInfoConnectedToStudent(OAuth2UserInfo oAuth2UserInfo) {
        return studentRepository.existsById(oAuth2UserInfo.getId());
    }

    public OAuth2UserInfo findOAuth2UserInfoByEmail(String email) {
		return oAuth2UserInfoRepository.findByEmail(email)
            .orElseThrow(OAuth2UserInfoNotFoundException::new);
    }

    public Student findStudentByOAuth2UserInfo(OAuth2UserInfo oAuth2UserInfo) {
        return studentRepository.findStudentById(oAuth2UserInfo.getId())
            .orElseThrow(StudentNotFoundException::new);
    }

    public Student findStudentByNameAndNumber(String studentName, String studentNumber) {
        return studentRepository.findByStudentNameAndStudentNumber(studentName, studentNumber)
            .orElseThrow(StudentNotFoundException::new);
    }

    public Student findStudentByStudentNumber(String studentNumber) {
        return studentRepository.findByStudentNumber(studentNumber)
            .orElseThrow(StudentNotFoundException::new);
    }
}


DuesService.java



@Service
@Transactional(readOnly = true)
@RequiredArgsConstructor
public class DuesService {
	private final DuesRepository duesRepository;

	/**
	 * 학생회비 납부 여부 설정
	 * - 만약 해당 학생이 학생회비를 납부한 기록이 있다면, 해당 기록을 수정한다.
	 * - 만약 해당 학생이 학생회비를 납부한 기록이 없다면, 새로운 기록을 생성한다.
	 * @param studentId 학생 식별자
	 * @param isDues 학생회비 납부 여부
	 */
	@Transactional
	public void updateDues(Long studentId, boolean isDues) {
		if (duesRepository.existsDuesById(studentId)) {
			Dues dues = duesRepository.findDuesById(studentId)
				.orElseThrow(DuesNotFoundException::new);
			modifyDues(dues, isDues);
		} else {
			saveDues(studentId, isDues);
		}
	}

	private void modifyDues(Dues dues, boolean isDues) {
		dues.updateDues(isDues);
		duesRepository.save(dues);
	}

	private void saveDues(Long studentId, boolean isDues) {
		duesRepository.save(
			Dues.builder()
				.id(studentId)
				.dues(isDues)
				.build()
		);
	}
}


ApplyService.java




@Service
@Transactional(readOnly = true)
@RequiredArgsConstructor
public class ApplyService {
	/* Internal Dependencies */
	private final ApplyRepository applyRepository;

	/* External Dependencies */
	private final ApplyFormService applyFormService;
	private final StudentService studentService;
	private final ReportService reportService;

	/**
	 * Handles the creation of a primary application.
	 *
	 * @param createDto The DTO containing application details.
	 * @return The DTO representing the created application.
	 */
	@Transactional
	public ApplyReadDto handlePrimaryApply(ApplyCreateDto createDto) {
		return processApplication(createDto, ApplyPeriod.PRIMARY);
	}

	/**
	 * Handles the creation of an additional application.
	 *
	 * @param createDto The DTO containing application details.
	 * @return The DTO representing the created application.
	 */
	@Transactional
	public ApplyReadDto handleAdditionalApply(ApplyCreateDto createDto) {
		return processApplication(createDto, ApplyPeriod.ADDITIONAL);
	}

	/**
	 * Handles the creation of a replacement application along with a report.
	 *
	 * @param createDto The DTO containing application and report details.
	 * @return The DTO representing the created application.
	 */
	@Transactional
	public ApplyReportReadDto handleReplacementApply(ApplyReportCreateDto createDto) {
		ApplyReadDto applyReadDto = processApplication(createDto.apply(), ApplyPeriod.REPLACEMENT);
		Report report = attachReport(createDto.content(), applyReadDto.applyId());
		return ApplyReportReadDto.of(applyReadDto, report);
	}

	/**
	 * Processes the application based on the specified period and report content.
	 *
	 * @param createDto    The DTO containing application details.
	 * @param period       The period of the application.
	 * @return The DTO representing the created application.
	 */
	private ApplyReadDto processApplication(ApplyCreateDto createDto, ApplyPeriod period) {
		ApplyForm activeApplyForm = applyFormService.getActiveApplyForm();
		validateApplicationPeriod(activeApplyForm, period);

		Student student = retrieveStudent(createDto);
		Apply apply = applyRepository.save(createDto.toEntity(student, period));

		return ApplyReadDto.fromEntity(apply, student);
	}

	/**
	 * Attaches a report to the specified application.
	 *
	 * @param content  The content of the report.
	 * @param applyId The ID of the application to attach the report to.
	 */
	private Report attachReport(String content, Long applyId) {
		Apply apply = applyRepository.findById(applyId)
			.orElseThrow(ApplyNotFoundException::new);
		return reportService.writeReport(content, apply);
	}

	/**
	 * Validates whether the current time is within the application period.
	 *
	 * @param applyForm The active application form.
	 * @param period    The period of the application.
	 */
	private void validateApplicationPeriod(ApplyForm applyForm, ApplyPeriod period) {
		LocalDateTime now = DateTimeUtil.now();
		if (!period.isWithinPeriod(applyForm, now)) {
			throw new InvalidApplyPeriodException();
		}
	}

	/**
	 * Retrieves the student based on the provided application details.
	 *
	 * @param createDto The DTO containing student details.
	 * @return The Student entity.
	 */
	private Student retrieveStudent(ApplyCreateDto createDto) {
		return studentService.findStudentByNameAndNumber(
			createDto.studentName(),
			createDto.studentNumber()
		);
	}

	/**
	 * Retrieves the application by the student number.
	 *
	 * @param studentNumber The student number to search for.
	 * @return The DTO representing the application.
	 */
	public ApplyReadDto getApplyByStudentNumber(String studentNumber) {
		Student student = studentService.findStudentByStudentNumber(studentNumber);
		Apply apply = applyRepository.findByStudent(student)
			.orElseThrow(ApplyNotFoundException::new);
		return ApplyReadDto.fromEntity(apply, student);
	}
}


ApplyFormService.java




@Service
@Transactional(readOnly = true)
@RequiredArgsConstructor
public class ApplyFormService {
	/* internal dependency */
	private final ApplyFormRepository applyFormRepository;

	@Transactional
	public ApplyFormReadDto createApplyForm(ApplyFormCreateDto requestBody) {
		/* Check if the student not exists */
		if (applyFormRepository.existsByYearAndSemester(requestBody.year(), requestBody.semester()))
			throw new ApplyFormDuplicatedException();

		/* Save the apply entity */
		ApplyForm applyForm = applyFormRepository.save(requestBody.toEntity());

		/* Return the created apply entity */
		return ApplyFormReadDto.fromEntity(applyForm);
	}


	@Transactional
	public ApplyFormReadDto updateApplyForm(Integer year, Integer semester, ApplyFormUpdateDto requestBody) {
		/* Check if the student exists */
		ApplyForm applyForm = applyFormRepository.findByYearAndSemester(year, semester)
			.orElseThrow(ApplyFormNotFoundException::new);

		/* Update the apply entity */
		applyForm.update(requestBody);
		applyFormRepository.save(applyForm);

		/* Return the updated apply entity */
		return ApplyFormReadDto.fromEntity(applyForm);
	}

	@Transactional
	public void deleteApplyForm(Integer year, Integer semester) {
		/* Check if the student exists */
		ApplyForm applyForm = applyFormRepository.findByYearAndSemester(year, semester)
			.orElseThrow(ApplyFormNotFoundException::new);

		/* Delete the apply entity */
		applyFormRepository.delete(applyForm);
	}

	public ApplyFormReadDto getApplyForm(Integer year, Integer semester) {
		/* Check if the student exists */
		ApplyForm applyForm = applyFormRepository.findByYearAndSemester(year, semester)
			.orElseThrow(ApplyFormNotFoundException::new);

		/* Return the apply entity */
		return ApplyFormReadDto.fromEntity(applyForm);
	}

	public List<ApplyFormReadDto> getAllApplyForms() {
		/* Return the apply entities */
		return applyFormRepository.findAll().stream()
			.map(ApplyFormReadDto::fromEntity)
			.collect(Collectors.toList());
	}

	@Transactional
	public ApplyFormReadDto updateApplyFormStatus(Integer year, Integer semester) {
		/* Check if the student exists */
		ApplyForm applyForm = applyFormRepository.findByYearAndSemester(year, semester)
			.orElseThrow(ApplyFormNotFoundException::new);

		/* Update the apply entity */
		if (applyForm.getStatus() == ApplyFormStatus.INACTIVE) {
			if (isActiveApplyForm())
				throw new ApplyFormDuplicatedException();
			applyForm.updateStatus(ApplyFormStatus.ACTIVE);
		} else {
			applyForm.updateStatus(ApplyFormStatus.INACTIVE);
		}

		applyFormRepository.save(applyForm);

		/* Return the updated apply entity */
		return ApplyFormReadDto.fromEntity(applyForm);
	}

	public ApplyFormReadDto getNowApplyForm() {
		ApplyForm applyForm = getActiveApplyForm();
		return ApplyFormReadDto.fromEntity(applyForm);
	}

	public boolean isActiveApplyForm() {
		long activeCount = applyFormRepository.countByStatus(ApplyFormStatus.ACTIVE);
		return activeCount == 1;
	}

	public ApplyForm getActiveApplyForm() {
		if (!isActiveApplyForm())
			throw new ApplyFormNotFoundException();
		return applyFormRepository.findByStatus(ApplyFormStatus.ACTIVE)
			.orElseThrow(ApplyFormNotFoundException::new);
	}
}


ReportService.java



@Service
@Transactional(readOnly = true)
@RequiredArgsConstructor
public class ReportService {
	/* internal dependency */
	private final ReportRepository reportRepository;

	@Transactional
	public Report writeReport(String content, Apply apply) {
		return reportRepository.save(Report.builder()
			.content(content)
			.apply(apply)
			.build());
	}
}


